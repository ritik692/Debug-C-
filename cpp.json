{
    // Place your snippets for cpp here. Each snippet is defined under a snippet name and has a prefix, body and 
    // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are:
    // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the 
    // same ids are connected.
    // Example:
    // "Print to console": {
    // 	"prefix": "log",
    // 	"body": [
    // 		"console.log('$1');",
    // 		"$2"
    // 	],
    // 	"description": "Log output to console"
    // }
    "Trie": {
        "prefix": "trie",
        "body": [
            "class TrieNode {",
            "    public:",
            "        char data;",
            "        TrieNode* children[26];",
            "        bool isTerminal;",
            "",
            "        TrieNode(char ch) {",
            "            this->data = ch;",
            "            this->isTerminal = false;",
            "            for(int i=0; i<26; i++) {",
            "                this->children[i] = NULL;",
            "            }",
            "        }",
            "};",
            "",
            "class Trie {",
            "    public :",
            "        TrieNode* root;",
            "",
            "        Trie() {",
            "            root = new TrieNode('*');",
            "        }",
            "",
            "        void insertUtil(TrieNode* &root, string &word ,int idx) {",
            "            if(word.length() == idx) {",
            "                root->isTerminal = true;",
            "                return;",
            "            }",
            "",
            "            // Assumption : Word will be in lowercase",
            "            int index = word[idx] - 'a';",
            "            TrieNode* child;",
            "",
            "            if(root->children[index] != NULL) {",
            "                // Character Present",
            "                child = root->children[index];",
            "            } else {",
            "                // Character Absent",
            "                child = new TrieNode(word[0]);",
            "                root->children[index] = child;",
            "            }",
            "",
            "            // Recursion",
            "            insertUtil(child, word ,idx+1);",
            "        }",
            "",
            "        void insertNode(string &word) {",
            "            insertUtil(root, word,0);",
            "        }",
            "",
            "        bool searchUtil(TrieNode* root, string &word ,int idx) {",
            "            // Base case",
            "            if(word.length() == idx) {",
            "                return root->isTerminal;",
            "            }",
            "",
            "            // Finding index through mapping",
            "            int index = word[idx] - 'a';",
            "            TrieNode* child;",
            "",
            "            if(root->children[index] != NULL) {",
            "                // Present",
            "                child = root->children[index];",
            "            } else {",
            "                // Absent",
            "                return false;",
            "            }",
            "",
            "            return searchUtil(child, word, idx+1);",
            "        }",
            "",
            "        bool search(string &word) {",
            "            return searchUtil(root, word, 0);",
            "        }",
            "",
            "        bool removeUtil(TrieNode* root, string &word ,int idx) {",
            "            // Base case",
            "            if(word.length() == idx) {",
            "                if(root->isTerminal) {",
            "                    root->isTerminal = false;",
            "                    return true;",
            "                } else {",
            "                    return false;",
            "                }",
            "            }",
            "",
            "            // Finding index through mapping",
            "            int index = word[idx] - 'a';",
            "            TrieNode* child;",
            "",
            "            if(root->children[index] != NULL) {",
            "                // Present",
            "                child = root->children[index];",
            "            } else {",
            "                // Absent",
            "                return false;",
            "            }",
            "",
            "            return removeUtil(child, word, idx+1);",
            "        }",
            "",
            "        bool remove(string &word) {",
            "            return removeUtil(root, word, 0);",
            "        }",
            "",
            "};",
        ],
        "description": "Trie"
    },
    "Leetcode ": {
        "prefix": "lc",
        "body": [
            "#include<bits/stdc++.h>",
            "using namespace std;",
            "#define ll long long",
            "",
            "",
            "int main(){",
            "  Solution s;",
            "  $1",
            "}"
        ],
        "description": "leetcode template for debugging"
    },
    "String hashing": {
        "prefix": "stringHash",
        "body": [
            "class StringHash {",
            "public:",
    "	vector<long long>ps1,ps2;",
    "	long long Q1 = 271, Q2 = 277, M1 = 1000000007, M2 = 998244353;",
    "	StringHash(string s) {",
    "		ps1 = vector<long long>(s.size()+1); ps2 = vector<long long>(s.size()+1);",
    "		for (int i = 1; i <= s.size(); i++) {",
    "			long long c = s[i-1] + 1;",
    "			ps1[i] = ((Q1 * ps1[i-1]) + c)%M1;",
    "			ps2[i] = ((Q2 * ps2[i-1]) + c)%M2;",
    "		}",
    "	}",
    "	long long int powxy(long long int x, long long int y, long long M) {",
    "		if (y == 0) return 1;",
    "		if (y%2 == 1) return (x*powxy(x, y-1, M))%M;",
    "		long long int t = powxy(x, y/2, M);",
    "		return (t*t)%M;",
    "	}",
    "	long long substrHash1(int firstIndex, int lastIndex) {",
    "		long long rem = (powxy(Q1,lastIndex-firstIndex+1,M1) * ps1[firstIndex])%M1;",
    "		return (ps1[lastIndex+1] - rem + M1)%M1;",
    "	}",
    "	long long substrHash2(int firstIndex, int lastIndex) {",
    "		long long rem = (powxy(Q2,lastIndex-firstIndex+1,M2) * ps2[firstIndex])%M2;",
    "		return (ps2[lastIndex+1] - rem + M2)%M2;",
    "	}",
    "	pair<long long, long long> substrHash(int firstIndex, int lastIndex) {",
    "		return {substrHash1(firstIndex, lastIndex), substrHash2(firstIndex, lastIndex)};",
    "	}",
            "};"
        ],
        "description": "String Hashing"
    },
    "Segment Tree": {
        "prefix": "segTree",
        "body": [
            "class segmentTree{",
            "    public:",
            "    vector<ll> segTree;",
            "    // vector<ll> lazy;",
            "    vector<ll> a;",
            "    segmentTree(int n)",
            "    {",
            "        segTree.resize(4 * n + 10 , 0);",
            "        // lazy.resize(4 * n + 10);",
            "    }",
            "    ll merge(ll p,ll q)",
            "    {",
            "        return max(p, q);",
            "    }",
            "    void build(ll idx, ll l, ll r, vector<ll> &a)",
            "    {",
            "        if (l == r)",
            "        {",
            "            segTree[idx]=a[l];",
            "            return;",
            "        }",
            "        ll m = (l + r) / 2;",
            "        build(idx * 2 + 1, l, m, a);",
            "        build(idx * 2 + 2, m + 1, r, a);",
            "        segTree[idx] = merge(segTree[idx * 2 + 1], segTree[idx * 2 + 2]);",
            "    }",
            "    // void lazyUpdate(ll idx, ll l, ll r, ll i, ll j, ll x)",
            "    // {",
            "    //     if (lazy[idx] > 0)",
            "    //     {",
            "    //         if (l < r)",
            "    //             lazy[idx * 2 + 1] = (lazy[idx * 2 + 1] + lazy[idx]);",
            "    //         if (l < r)",
            "    //             lazy[idx * 2 + 2] = (lazy[idx * 2 + 2] + lazy[idx]);",
            "    //         segTree[idx] += lazy[idx];",
            "    //         lazy[idx] = 0;",
            "    //     }",
            "    //     if (l > j or i > r or l > r)",
            "    //         return;",
            "    //     if (i <= l and r <= j)",
            "    //     {",
            "    //         if (l < r)",
            "    //             lazy[idx * 2 + 1] = (lazy[idx * 2 + 1] + x);",
            "    //         if (l < r)",
            "    //             lazy[idx * 2 + 2] = (lazy[idx * 2 + 2] + x);",
            "    //         segTree[idx] += x;",
            "    //     }",
            "    //     else",
            "    //     {",
            "    //         int m = (l + r) / 2;",
            "    //         lazyUpdate(idx * 2 + 1, l, m, i, j, x);",
            "    //         lazyUpdate(idx * 2 + 2, m + 1, r, i, j, x);",
            "    //         segTree[idx] = merge(segTree[idx * 2 + 1], segTree[idx * 2 + 2]);",
            "    //     }",
            "    // }",
            "    // ll lazyQuery(ll idx, ll l, ll r, ll i, ll j)",
            "    // {",
            "    //     if (lazy[idx] > 0)",
            "    //     {",
            "    //         if (l < r)",
            "    //             lazy[idx * 2 + 1] = (lazy[idx * 2 + 1] + lazy[idx]);",
            "    //         if (l < r)",
            "    //             lazy[idx * 2 + 2] = (lazy[idx * 2 + 2] + lazy[idx]);",
            "    //         segTree[idx] += lazy[idx];",
            "    //         lazy[idx] = 0;",
            "    //     }",
            "    //     if (l > j or i > r or l > r)",
            "    //         return 0;",
            "    //     if (i <= l and r <= j)",
            "    //         return segTree[idx];",
            "    //     else",
            "    //     {",
            "    //         ll m = (l + r) / 2;",
            "    //         return merge(lazyQuery(idx * 2 + 1, l, m, i, j), lazyQuery(idx * 2 + 2, m + 1, r, i, j));",
            "    //     }",
            "    // }",
            "    void update(ll idx, ll l, ll r, ll i, ll j, ll x)",
            "    {",
            "        if (l > j or i > r or l > r)",
            "            return;",
            "        if (i == l and r == j)",
            "        {",
            "            segTree[idx] = x;",
            "            return;",
            "        }",
            "        ll m = (l + r) / 2;",
            "        update(idx * 2 + 1, l, m, i, j, x);",
            "        update(idx * 2 + 2, m + 1, r, i, j, x);",
            "        segTree[idx] = merge(segTree[idx * 2 + 1], segTree[idx * 2 + 2]);",
            "    }",
            "",
            "    ll query(ll idx, ll l, ll r, ll i, ll j)",
            "    {",
            "        if (l > j or i > r or l > r)",
            "            return 0;",
            "        if (i <= l and r <= j)",
            "        {",
            "            return segTree[idx];",
            "        }",
            "        ll m = (l + r) / 2;",
            "        ll  ans=merge(query(idx * 2 + 1, l, m, i, j), query(idx * 2 + 2, m + 1, r, i, j));",
            "        return ans;",
            "    }",
            "};"
        ],
        "description": "Segment Tree"
    },
    "ncr": {
        "prefix": "ncr",
        "body": [
            "unsigned long long power(unsigned long long x, int y, int p)",
            "{",
    "	unsigned long long res = 1; // Initialize result",
            "",
    "	x = x % p; // Update x if it is more than or",
    "	// equal to p",
            "",
    "	while (y > 0) {",
            "",
    "		// If y is odd, multiply x with result",
    "		if (y & 1)",
    "			res = (res * x) % p;",
            "",
    "		// y must be even now",
    "		y = y >> 1; // y = y/2",
    "		x = (x * x) % p;",
    "	}",
    "	return res;",
            "}",
            "// Returns n^(-1) mod p",
            "unsigned long long modInverse(unsigned long long n, int p)",
            "{",
    "	return power(n, p - 2, p);",
            "}",
            "unsigned long long mul(unsigned long long x,unsigned long long y, int p)",
            "{",
    "	return x * 1ull * y % p;",
            "}",
            "unsigned long long divide(unsigned long long x,unsigned long long y, int p)",
            "{",
    "	return mul(x, modInverse(y, p), p);",
            "}",
            "// Returns nCr % p using Fermat's little",
            "// theorem.",
            "unsigned long long nCrModPFermat(unsigned long long n,",
    "								int r, int p)",
            "{",
    "	// If n<r, then nCr should return 0",
    "	if (n < r)",
    "		return 0;",
    "	// Base case",
    "	if (r == 0)",
    "		return 1;",
    "	// if n-r is less calculate nCn-r",
    "	if (n - r < r)",
    "		return nCrModPFermat(n, n - r, p);",
            "",
    "	// Fill factorial array so that we",
    "	// can find all factorial of r, n",
    "	// and n-r",
    "	unsigned long long res = 1;",
    "	// keep multiplying numerator terms and dividing denominator terms in res",
    "	for (int i = r; i >= 1; i--)",
    "		res = divide(mul(res, n - i + 1, p), i, p);",
    "	return res;",
            "}"
        ],
        "description": "combinations, ncr"
    },
    "DSU": {
        "prefix": "dsu",
        "body": [
            "class dsu",
            "{",
            "public:",
            "    ll v;",
            "    vector<ll> parent, size, rank;",
            "    dsu(ll n)",
            "    {",
            "        v = n;",
            "        parent.resize(v + 1);",
            "        size.resize(v + 1, 1);",
            "        rank.resize(v + 1, 1);",
            "        for (int i = 0; i <= v; i++)",
            "        {",
            "            parent[i] = i;",
            "        }",
            "    }",
            "    int find(int node)",
            "    {",
            "        return parent[node] = (parent[node] == node) ? node : find(parent[node]);",
            "    }",
            "    void unionBySize(int a, int b)",
            "    {",
            "        a = find(a);",
            "        b = find(b);",
            "        if (a == b)",
            "            return;",
            "        if (size[a] >= size[b])",
            "        {",
            "            parent[b] = a;",
            "            size[a] += size[b];",
            "        }",
            "        else",
            "        {",
            "            parent[a] = b;",
            "            size[b] += size[a];",
            "        }",
            "    }",
            "    void unionByRank(int a, int b)",
            "    {",
            "        a = find(a);",
            "        b = find(b);",
            "        if (a == b)",
            "            return;",
            "        if (rank[a] > size[b])",
            "        {",
            "            parent[b] = a;",
            "        }",
            "        else if (rank[b] > rank[a])",
            "        {",
            "            parent[a] = b;",
            "        }",
            "        else",
            "        {",
            "            parent[b] = a;",
            "            rank[a]++;",
            "        }",
            "    }",
            "};"
        ],
        "description": "Disjoint Set Union"
    },
    "CP template": {
        "prefix": "z",
        "body": [
            "//******************************************************************",
    "//						Author: Ritik Arora",
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define fastio() ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL)",
            "",
            "typedef long long ll;",
            "typedef unsigned long long ull;",
            "typedef long double lld;",
            "",
            "#include <ext/pb_ds/assoc_container.hpp> // Common file",
            "using namespace __gnu_pbds;",
            "typedef tree<ll, null_type, less<ll>, rb_tree_tag,tree_order_statistics_node_update> ordered_set; // find_by_order, order_of_key",
            "",
            "#define pp pair<int, int>",
            "#define ppl pair<ll, ll>",
            "#define ff first",
            "#define ss second",
            "#define set_bits __builtin_popcountll",
            "#define nline '\\n'",
            "#define inf LLONG_MAX",
            "#define vi vector<int>",
            "#define vvi vector<vector<int>>",
            "#define vl vector<long long>",
            "#define vvl vector<vector<long long>>",
            "ll mod1 = 1e9 + 7;",
            "ll mod2 = 998244353;",
            "",
            "bool revsort(ll a, ll b) { return a > b; }",
            "ll gcd(ll a, ll b)",
            "{",
            "    if (b > a)",
            "    {",
            "        return gcd(b, a);",
            "    }",
            "    if (b == 0)",
            "    {",
            "        return a;",
            "    }",
            "    return gcd(b, a % b);",
            "}",
            "ll expo(ll a, ll b, ll mod)",
            "{",
            "    ll res = 1;",
            "    while (b > 0)",
            "    {",
            "        if (b & 1)",
            "            res = (res * a) % mod;",
            "        a = (a * a) % mod;",
            "        b = b >> 1;",
            "    }",
            "    return res;",
            "}",
            "",
            "vector<ll> sieve(int n)",
            "{",
            "    int *arr = new int[n + 1]();",
            "    vector<ll> vect;",
            "    for (int i = 2; i <= n; i++)",
            "        if (arr[i] == 0)",
            "        {",
            "            vect.push_back(i);",
            "            for (int j = 2 * i; j <= n; j += i)",
            "                arr[j] = 1;",
            "        }",
            "    return vect;",
            "}",
            "",
            "ll mminvprime(ll a, ll b) { return expo(a, b - 2, b); }",
            "ll mod_add(ll a, ll b, ll m)",
            "{",
            "    a = a % m;",
            "    b = b % m;",
            "    return (((a + b) % m) + m) % m;",
            "}",
            "ll mod_mul(ll a, ll b, ll m)",
            "{",
            "    a = a % m;",
            "    b = b % m;",
            "    return (((a * b) % m) + m) % m;",
            "}",
            "ll mod_sub(ll a, ll b, ll m)",
            "{",
            "    a = a % m;",
            "    b = b % m;",
            "    return (((a - b) % m) + m) % m;",
            "}",
            "ll mod_div(ll a, ll b, ll m)",
            "{",
            "    a = a % m;",
            "    b = b % m;",
            "    return (mod_mul(a, mminvprime(b, m), m) + m) % m;",
            "} // only for prime m",
            "",
            "#define yes cout<<\"YES\"<<endl;",
            "#define no cout<<\"NO\"<<endl;",
            "",
            "",
            "",
            "void solve()",
            "{",
            "\t$1",
            "}",
            "int main()",
            "{",
            "\t// unordered_map<long long int,int,custom_hash> mp;",
            "\t// StringHash hash(word);",
            "\t// hash.substrHash(idx1,idx2)==hash.substrHash(idx3,idx4);",
            "\t// Trie* T = new Trie();",
            "\t// string ritik=\"ritik\";",
            "\t// T->insertNode(ritik);",
            "\t#ifndef ONLINE_JUDGE",
            "\tfreopen(\"Error.txt\", \"w\", stderr);",
            "\t#endif",
            "\tfastio();",
            "\tint t;",
            "\tcin >> t;",
            "\twhile (t--)",
            "\t{",
            "\t\tsolve();",
            "\t}",
            "\treturn 0;",
            "}"
        ],
        "description": "This is a boilerplate"
    },
    "Meta hackercup": {
        "prefix": "meta",
        "body": [
            "#include <bits/stdc++.h>",
            "using namespace std;",
            "#define ll long long",
            "#define nline '\\n'",
            "void solve()",
            "{",
            "    ",
            "}",
            "",
            "void main_()",
            "{",
            "    // freopen(\"input.txt\", \"r\", stdin);",
            "    // freopen(\"output.txt\", \"w\", stdout);",
            "    int t;",
            "    cin >> t;",
            "    for (int i = 1; i <= t; i++)",
            "    {",
            "        cout << \"Case #\" << i << \": \";",
            "        solve();",
            "    } ",
            "}",
            "",
            "static void run_with_stack_size(void (*func)(void), size_t stsize)",
            "{",
            "    char *stack, *send;",
            "    stack = (char *)malloc(stsize);",
            "    send = stack + stsize - 16;",
            "    send = (char *)((uintptr_t)send / 16 * 16);",
            "    asm volatile(",
            "        \"mov %%esp, (%0)\\n\"",
            "        \"mov %0, %%esp\\n\"",
            "        :",
            "        : \"r\"(send));",
            "    func();",
            "    asm volatile(\"mov (%0), %%esp\\n\" : : \"r\"(send));",
            "    free(stack);",
            "}",
            "",
            "int main()",
            "{",
            "    run_with_stack_size(main_, 1024 * 1024 * 1024); // run with 1 GB stack",
            "    return 0;",
            "}",
            ""
        ],
        "description": "Meta Hackercup template to increase stack size"
    },
    "custom_hash": {
        "prefix": "custom_hash",
        "body": [
            "struct custom_hash {",
            "    static uint64_t splitmix64(uint64_t x) {",
            "        // http://xorshift.di.unimi.it/splitmix64.c",
            "        x += 0x9e3779b97f4a7c15;",
            "        x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "        x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "        return x ^ (x >> 31);",
            "    }",
            "",
            "    size_t operator()(uint64_t x) const {",
            "        static const uint64_t FIXED_RANDOM = chrono::steady_clock::now().time_since_epoch().count();",
            "        return splitmix64(x + FIXED_RANDOM);",
            "    }",
            "};"
        ],
        "description": "custom_hash to avoid hash collision(n2 blow up time)"
    }
}
